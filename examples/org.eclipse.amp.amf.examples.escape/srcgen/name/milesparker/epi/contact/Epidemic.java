package name.milesparker.epi.contact;

import java.util.ArrayList;
import java.util.List;
import java.util.Collections;

import org.eclipse.core.runtime.IAdapterFactory;
import org.eclipse.amp.agf.IGraphicsAdapted;
import org.eclipse.amp.agf.IGraphicsAdapter;

import org.eclipse.swt.graphics.Color;
import org.eclipse.jface.viewers.IColorProvider;

import org.ascape.model.Agent;
import org.ascape.model.Cell;
import org.ascape.model.CellOccupant;
import org.ascape.model.HostCell;
import org.ascape.model.LocatedAgent;
import org.ascape.model.Scape;
import org.ascape.model.event.ScapeEvent;
import org.ascape.model.rule.Rule;
import org.ascape.model.rule.ExecuteThenUpdate;
import org.ascape.model.space.CollectionSpace;
import org.ascape.model.space.Coordinate;
import org.ascape.model.space.Coordinate2DDiscrete;
import org.ascape.model.space.Graph;
import org.ascape.model.space.Location;
import org.ascape.model.space.Singleton;
import org.ascape.runtime.NonGraphicRunner;
import org.ascape.util.Conditional;
import org.ascape.util.data.DataPoint;
import org.ascape.util.data.DataPointConcrete;
import org.ascape.util.vis.ColorFeature;
import org.ascape.util.vis.ColorFeatureConcrete;
import org.ascape.view.vis.ChartView;
import org.ascape.view.vis.GEFView;
import org.ascape.view.vis.GraphView;

import org.eclipse.amp.escape.runtime.extension.IAgentChild;

/**
 * <!-- begin-user-doc -->
 * Epidemic Java Implementation.
 * A simple model of epidemic dynamics. We define individual agents with different disease states. The progression of disease moves from succeptible to exposed to infectious (either symptomatic or asymptomatic) to some outcome state. Agents can transmit infection to their immediate neighbors. 

For some background on the general approach, see Joshua M. Epstein. "Generative Social Science". 2006. Princeton. 

Copyright 2009, Miles Parker. Released under Eclipse Public License. All uses should be attributed.
 * Generated by AMF for model: EpidemicContact.metaabm in project: org.eclipse.amp.amf.examples.escape 
 * <!-- end-user-doc -->
 * @generated
 */
public class Epidemic extends Scape implements IGraphicsAdapted {

	/**
	 * <!-- begin-user-doc -->
	 * The number of individuals to create.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int individualCount = 1500;
	/**
	 * <!-- begin-user-doc -->
	 * The probability that any given individual will be infected at the beginning of the model run. For example, if this value is .15, and their are 100 individuals in the model, roughly 15 of those individuals will be infected at time 0.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private double initialInfectionProbability = .005;
	/**
	 * <!-- begin-user-doc -->
	 * The minimum probability that proximity to a single neighbor for a single period will result in transmission of infection. At the start of each model run, each individual is assigned a contact transmission probability between the minimum and maximum value. For example, if this value was .08 and the maximum value was 0.12 a given individual could have any value between those two, but the average transmission probability would be around .1. If minium and maximum values are the same, then all individuals will have the same chance of passing along infection to a given neighbor. This value must be between 0.0 and 1.0 and less than or equal to Max Contact transmission Probability.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private double minContactTransmissionProbability = .08;
	/**
	 * <!-- begin-user-doc -->
	 * The maximum probability that proximity to a single neighbor for a single period will result in transmission of infection. See Min Contact Probability for more information. Must be a value between 0.0 and 1.0 and greater or equal to Min Contact Transmission Probability.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private double maxContactTransmissionProbability = .16;
	/**
	 * <!-- begin-user-doc -->
	 * The current probability that death will occur for a given individual as a result of infection. Some number between 0.0 and 1.0.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private double caseMortalityRate = .05;
	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int periodsperDay = 24;
	/**
	 * <!-- begin-user-doc -->
	 * The minimum amount of time from initial exposure to infectious asymptomatic or symptomatic state. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int minPeriodExposure = 24;
	/**
	 * <!-- begin-user-doc -->
	 * Maximum time from initial exposure to infectious asymptomatic or symptomatic state. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int maxPeriodExposure = 72;
	/**
	 * <!-- begin-user-doc -->
	 * Maximum time spent infected without showing symptoms. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int minPeriodAsymptomInfection = 24;
	/**
	 * <!-- begin-user-doc -->
	 * Maximum time spent infected without showing symptoms. May be zero!
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int maxPeriodAsymptomInfection = 96;
	/**
	 * <!-- begin-user-doc -->
	 * Minimum time spent infected with obvious symptoms. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int minPeriodSymptomInfection = 24;
	/**
	 * <!-- begin-user-doc -->
	 * Maximum time spent infected with obvious symptoms. 1 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int maxPeriodSymptomInfection = 168;
	/**
	 * <!-- begin-user-doc -->
	 * The chance that an agent will move within a given period. May be any value between 0.0 and 1.0.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private double movementProbability = .5;
	/**
	 * <!-- begin-user-doc -->
	 * The size of each dimension.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int[] cityDimensions = new int[2];
	/**
	 * <!-- begin-user-doc -->
	 * The horizontal extent of the space.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int cityWidth = 40;
	/**
	 * <!-- begin-user-doc -->
	 * The vertical extent of the space.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int cityHeight = 100;
	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private Scape city = null;
	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private Scape contacts = null;

	private List<IAgentChild> children;

	public List<IAgentChild> getChildren() {
		return children;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Constructs a new Epidemic.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public Epidemic() {

		children = new ArrayList<IAgentChild>();

	}

	//todo, make this a useful value for evaluating compatibility of different versions of generated classes

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private static final long serialVersionUID = 89989998L;

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private static long nextUniqueID;

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private long uniqueID;

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public long getUID() {
		if (uniqueID == 0) {
			uniqueID = nextUniqueID++;
		}
		return uniqueID;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Clones the agent, ensuring that a unique id is assigned.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public Object clone() {
		try {
			Epidemic clone = (Epidemic) super.clone();
			clone.uniqueID = 0;
			return clone;
		} catch (Exception e) {
			throw new RuntimeException("Unexpected cloning exception: " + e);
		}
	}

	org.ascape.model.Scape individualScape;

	/**
	 * <!-- begin-user-doc -->
	 * Create an instance of Individual that will be used to populate the individualScape.
	 * Overide to customize the prototype, for example to change the views created for a member scape.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected Individual createIndividualPrototype() {
		Individual individual = new Individual();
		individual.setCoordinate(new Coordinate2DDiscrete(0, 0));
		return individual;
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	static int next_vm_id;

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	int vm_unique_id;

	/**
	 * <!-- begin-user-doc -->
	 * Creates the members of Epidemic.
	 * <!-- end-user-doc --> 
	 * @generated
	 */
	public void createScape() {
		super.createScape();

		setName("Epidemic");
		Individual individualProto = createIndividualPrototype();
		individualScape = new Scape();
		individualScape.setName("Individuals");
		individualScape.setPrototypeAgent(individualProto);
		individualScape.setExecutionOrder(Scape.RULE_ORDER);
		individualScape.setSize(getIndividualCount());
		city = new Scape(new org.ascape.model.space.Array2DEuclidian());
		city.setExecutionOrder(Scape.RULE_ORDER);
		city.setPrototypeAgent(new HostCell());
		city.setExtent(new org.ascape.model.space.Coordinate2DDiscrete(
				getCityWidth(), getCityHeight()));

		city.setName("Citys");
		((CollectionSpace) city.getSpace()).setPeriodic(false);
		add(city);
		contacts = new Scape(new org.ascape.model.space.Graph());
		contacts.setName("Contactss");
		add(contacts);

		add(individualScape);
		individualProto.setHostScape(city);
		city.getRules().clear();

		individualScape
				.addStatCollector(new org.ascape.util.data.StatCollectorCond(
						individualScape.getName() + " Population") {

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					private static final long serialVersionUID = 684614444640209893L;

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					@SuppressWarnings("unused")
					public final boolean meetsCondition(Object object) {
						return true;
					}
				});
		individualScape
				.addStatCollector(new org.ascape.util.data.StatCollectorCond(
						"Individual Susceptible Status") {

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					private static final long serialVersionUID = 6846144446402098985L;

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					public final boolean meetsCondition(Object individual) {
						return StatusEnum.susceptible == ((Individual) individual)
								.getStatus();
					}
				});

		individualScape
				.addStatCollector(new org.ascape.util.data.StatCollectorCond(
						"Individual Exposed Status") {

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					private static final long serialVersionUID = 6846144446402098985L;

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					public final boolean meetsCondition(Object individual) {
						return StatusEnum.exposed == ((Individual) individual)
								.getStatus();
					}
				});

		individualScape
				.addStatCollector(new org.ascape.util.data.StatCollectorCond(
						"Individual Asymptom Infectious Status") {

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					private static final long serialVersionUID = 6846144446402098985L;

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					public final boolean meetsCondition(Object individual) {
						return StatusEnum.asymptomInfectious == ((Individual) individual)
								.getStatus();
					}
				});

		individualScape
				.addStatCollector(new org.ascape.util.data.StatCollectorCond(
						"Individual Symptom Infectious Status") {

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					private static final long serialVersionUID = 6846144446402098985L;

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					public final boolean meetsCondition(Object individual) {
						return StatusEnum.symptomInfectious == ((Individual) individual)
								.getStatus();
					}
				});

		individualScape
				.addStatCollector(new org.ascape.util.data.StatCollectorCond(
						"Individual Recovered Status") {

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					private static final long serialVersionUID = 6846144446402098985L;

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					public final boolean meetsCondition(Object individual) {
						return StatusEnum.recovered == ((Individual) individual)
								.getStatus();
					}
				});

		individualScape
				.addStatCollector(new org.ascape.util.data.StatCollectorCond(
						"Individual Dead Status") {

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					private static final long serialVersionUID = 6846144446402098985L;

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					public final boolean meetsCondition(Object individual) {
						return StatusEnum.dead == ((Individual) individual)
								.getStatus();
					}
				});

		individualScape
				.addStatCollector(new org.ascape.util.data.StatCollectorCSAMM(
						"Individual Exposure End Period") {

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					private static final long serialVersionUID = 6846144446402098985L;

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					public final double getValue(Object individual) {
						return ((Individual) individual).getExposureEndPeriod();
					}
				});

		individualScape
				.addStatCollector(new org.ascape.util.data.StatCollectorCSAMM(
						"Individual Contact Transmission Probability") {

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					private static final long serialVersionUID = 6846144446402098985L;

					/**
					 * <!-- begin-user-doc -->
					 * 
					 * <!-- end-user-doc -->
					 * @generated
					 */
					public final double getValue(Object individual) {
						return ((Individual) individual)
								.getContactTransmissionProbability();
					}
				});

		individualScape.addInitialRule(new Rule("Initialize Location") {

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			private static final long serialVersionUID = 6846144446402098982L;

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			public void execute(Agent a) {
				((name.milesparker.epi.contact.Individual) a)
						.initializeLocation();
			}
		});
		individualScape.addRule(new Rule("Movement") {

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			private static final long serialVersionUID = 6846144446402098981L;

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			public void execute(Agent a) {
				((name.milesparker.epi.contact.Individual) a).movement();
			}
		});

		individualScape.addInitialRule(new Rule("Initialize State") {

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			private static final long serialVersionUID = 6846144446402098982L;

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			public void execute(Agent a) {
				((name.milesparker.epi.contact.Individual) a).initializeState();
			}
		});
		individualScape.addRule(new Rule("Transmission") {

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			private static final long serialVersionUID = 6846144446402098981L;

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			public void execute(Agent a) {
				((name.milesparker.epi.contact.Individual) a).transmission();
			}
		});
		individualScape.addRule(new Rule("Progression") {

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			private static final long serialVersionUID = 6846144446402098981L;

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			public void execute(Agent a) {
				((name.milesparker.epi.contact.Individual) a).progression();
			}
		});

	}

	/**
	 * <!-- begin-user-doc -->
	 * Creates UI views for Epidemic.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void createGraphicViews() {
		super.createGraphicViews();
		createChartViews();
		create2DViews();

		createGraphViews();
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void scapeSetup(ScapeEvent scapeEvent) {
		//Set the size of the scape populations, e.g. for mutable scapes that need to have their size reset

		individualScape.setSize(getIndividualCount());
	}

	/**
	 * <!-- begin-user-doc -->
	 * Returns the Scape containing Individuals.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public org.ascape.model.Scape getIndividualScape() {
		return individualScape;
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected void createChartViews() {
		ChartView chart = new ChartView();

		final Epidemic individualScape = new Epidemic();
		individualScape.setRunner(new NonGraphicRunner());
		Individual individual = new Individual() {

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			public void requestUpdate() {
			}

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			public Epidemic getEpidemic() {
				return individualScape;
			}
		};
		individualScape.add(individual);
		HostCell individualHost = new HostCell() {

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			public void requestUpdate() {
			}
		};
		individualHost.setOccupant((CellOccupant) individual);

		IColorProvider individualStyle2DColorProvider = new IndividualStyle2DColorProvider();

		individual.setStatus(StatusEnum.susceptible);
		chart.addSeries(
				"Count Individual Susceptible Status",
				getInferredChartColor(individual,
						individualStyle2DColorProvider));

		individual.setStatus(StatusEnum.exposed);
		chart.addSeries(
				"Count Individual Exposed Status",
				getInferredChartColor(individual,
						individualStyle2DColorProvider));

		individual.setStatus(StatusEnum.asymptomInfectious);
		chart.addSeries(
				"Count Individual Asymptom Infectious Status",
				getInferredChartColor(individual,
						individualStyle2DColorProvider));

		individual.setStatus(StatusEnum.symptomInfectious);
		chart.addSeries(
				"Count Individual Symptom Infectious Status",
				getInferredChartColor(individual,
						individualStyle2DColorProvider));

		individual.setStatus(StatusEnum.recovered);
		chart.addSeries(
				"Count Individual Recovered Status",
				getInferredChartColor(individual,
						individualStyle2DColorProvider));

		individual.setStatus(StatusEnum.dead);
		chart.addSeries(
				"Count Individual Dead Status",
				getInferredChartColor(individual,
						individualStyle2DColorProvider));
		addView(chart);
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected void create2DViews() {
		addView(new GEFView());
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected void createGraphViews() {
		contacts.addView(new GraphView());
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public IGraphicsAdapter getGraphicsAdapter() {
		return EpidemicGraphicsAdapter.getDefault();
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private Color getInferredChartColor(Object agent,
			IColorProvider colorProvider) {
		Color color = colorProvider.getForeground(agent);
		if (color == ColorFeature.BLACK) {
			color = ColorFeatureConcrete.createHSB(
					(float) java.lang.Math.random() * 360f, 1.0f, 0.8f);
		}
		return color;
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static void main(String[] args) {
		(new NonGraphicRunner())
				.openInstance("name.milesparker.epi.contact.Epidemic");
	}

	/**
	 * <!-- begin-user-doc -->
	 * A simple model of epidemic dynamics. We define individual agents with different disease states. The progression of disease moves from succeptible to exposed to infectious (either symptomatic or asymptomatic) to some outcome state. Agents can transmit infection to their immediate neighbors. 

	For some background on the general approach, see Joshua M. Epstein. "Generative Social Science". 2006. Princeton. 

	Copyright 2009, Miles Parker. Released under Eclipse Public License. All uses should be attributed.
	 * <!-- end-user-doc -->
	 * @generated
	 */

	public void startSimulationAgentChild(int timeStep) {
		if (timeStep == getRoot().getRunner().getEarliestPeriod()) {
			for (IAgentChild tmp : children) {
				tmp.startSimulation(timeStep);
			}
		}
	}

	/**
	 * <!-- begin-user-doc -->
	 * A simple model of epidemic dynamics. We define individual agents with different disease states. The progression of disease moves from succeptible to exposed to infectious (either symptomatic or asymptomatic) to some outcome state. Agents can transmit infection to their immediate neighbors. 

	For some background on the general approach, see Joshua M. Epstein. "Generative Social Science". 2006. Princeton. 

	Copyright 2009, Miles Parker. Released under Eclipse Public License. All uses should be attributed.
	 * <!-- end-user-doc -->
	 * @generated
	 */

	public void calculateTimeStep(int timeStep) {
		for (IAgentChild tmp : children) {
			tmp.calculate(timeStep);
		}
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Individual Count property for Epidemic.
	 * @return The number of individuals to create.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getIndividualCount() {
		return individualCount;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Individual Count property for Epidemic.
	 * The number of individuals to create.
	 * @param _individualCount the new Individual Count value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setIndividualCount(int _individualCount) {
		individualCount = _individualCount;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Initial Infection Probability property for Epidemic.
	 * @return The probability that any given individual will be infected at the beginning of the model run. For example, if this value is .15, and their are 100 individuals in the model, roughly 15 of those individuals will be infected at time 0.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public double getInitialInfectionProbability() {
		return initialInfectionProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Initial Infection Probability property for Epidemic.
	 * The probability that any given individual will be infected at the beginning of the model run. For example, if this value is .15, and their are 100 individuals in the model, roughly 15 of those individuals will be infected at time 0.
	 * @param _initialInfectionProbability the new Initial Infection Probability value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setInitialInfectionProbability(
			double _initialInfectionProbability) {
		initialInfectionProbability = _initialInfectionProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Min Contact Transmission Probability property for Epidemic.
	 * @return The minimum probability that proximity to a single neighbor for a single period will result in transmission of infection. At the start of each model run, each individual is assigned a contact transmission probability between the minimum and maximum value. For example, if this value was .08 and the maximum value was 0.12 a given individual could have any value between those two, but the average transmission probability would be around .1. If minium and maximum values are the same, then all individuals will have the same chance of passing along infection to a given neighbor. This value must be between 0.0 and 1.0 and less than or equal to Max Contact transmission Probability.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public double getMinContactTransmissionProbability() {
		return minContactTransmissionProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Min Contact Transmission Probability property for Epidemic.
	 * The minimum probability that proximity to a single neighbor for a single period will result in transmission of infection. At the start of each model run, each individual is assigned a contact transmission probability between the minimum and maximum value. For example, if this value was .08 and the maximum value was 0.12 a given individual could have any value between those two, but the average transmission probability would be around .1. If minium and maximum values are the same, then all individuals will have the same chance of passing along infection to a given neighbor. This value must be between 0.0 and 1.0 and less than or equal to Max Contact transmission Probability.
	 * @param _minContactTransmissionProbability the new Min Contact Transmission Probability value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMinContactTransmissionProbability(
			double _minContactTransmissionProbability) {
		minContactTransmissionProbability = _minContactTransmissionProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Max Contact Transmission Probability property for Epidemic.
	 * @return The maximum probability that proximity to a single neighbor for a single period will result in transmission of infection. See Min Contact Probability for more information. Must be a value between 0.0 and 1.0 and greater or equal to Min Contact Transmission Probability.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public double getMaxContactTransmissionProbability() {
		return maxContactTransmissionProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Max Contact Transmission Probability property for Epidemic.
	 * The maximum probability that proximity to a single neighbor for a single period will result in transmission of infection. See Min Contact Probability for more information. Must be a value between 0.0 and 1.0 and greater or equal to Min Contact Transmission Probability.
	 * @param _maxContactTransmissionProbability the new Max Contact Transmission Probability value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMaxContactTransmissionProbability(
			double _maxContactTransmissionProbability) {
		maxContactTransmissionProbability = _maxContactTransmissionProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Case Mortality Rate property for Epidemic.
	 * @return The current probability that death will occur for a given individual as a result of infection. Some number between 0.0 and 1.0.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public double getCaseMortalityRate() {
		return caseMortalityRate;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Case Mortality Rate property for Epidemic.
	 * The current probability that death will occur for a given individual as a result of infection. Some number between 0.0 and 1.0.
	 * @param _caseMortalityRate the new Case Mortality Rate value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setCaseMortalityRate(double _caseMortalityRate) {
		caseMortalityRate = _caseMortalityRate;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Periods per Day property for Epidemic.
	 * @return 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getPeriodsperDay() {
		return periodsperDay;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Periods per Day property for Epidemic.
	 * 
	 * @param _periodsperDay the new Periods per Day value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setPeriodsperDay(int _periodsperDay) {
		periodsperDay = _periodsperDay;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Min Period Exposure property for Epidemic.
	 * @return The minimum amount of time from initial exposure to infectious asymptomatic or symptomatic state. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getMinPeriodExposure() {
		return minPeriodExposure;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Min Period Exposure property for Epidemic.
	 * The minimum amount of time from initial exposure to infectious asymptomatic or symptomatic state. 0 or greater.
	 * @param _minPeriodExposure the new Min Period Exposure value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMinPeriodExposure(int _minPeriodExposure) {
		minPeriodExposure = _minPeriodExposure;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Max Period Exposure property for Epidemic.
	 * @return Maximum time from initial exposure to infectious asymptomatic or symptomatic state. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getMaxPeriodExposure() {
		return maxPeriodExposure;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Max Period Exposure property for Epidemic.
	 * Maximum time from initial exposure to infectious asymptomatic or symptomatic state. 0 or greater.
	 * @param _maxPeriodExposure the new Max Period Exposure value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMaxPeriodExposure(int _maxPeriodExposure) {
		maxPeriodExposure = _maxPeriodExposure;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Min Period Asymptom Infection property for Epidemic.
	 * @return Maximum time spent infected without showing symptoms. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getMinPeriodAsymptomInfection() {
		return minPeriodAsymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Min Period Asymptom Infection property for Epidemic.
	 * Maximum time spent infected without showing symptoms. 0 or greater.
	 * @param _minPeriodAsymptomInfection the new Min Period Asymptom Infection value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMinPeriodAsymptomInfection(int _minPeriodAsymptomInfection) {
		minPeriodAsymptomInfection = _minPeriodAsymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Max Period Asymptom Infection property for Epidemic.
	 * @return Maximum time spent infected without showing symptoms. May be zero!
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getMaxPeriodAsymptomInfection() {
		return maxPeriodAsymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Max Period Asymptom Infection property for Epidemic.
	 * Maximum time spent infected without showing symptoms. May be zero!
	 * @param _maxPeriodAsymptomInfection the new Max Period Asymptom Infection value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMaxPeriodAsymptomInfection(int _maxPeriodAsymptomInfection) {
		maxPeriodAsymptomInfection = _maxPeriodAsymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Min Period Symptom Infection property for Epidemic.
	 * @return Minimum time spent infected with obvious symptoms. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getMinPeriodSymptomInfection() {
		return minPeriodSymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Min Period Symptom Infection property for Epidemic.
	 * Minimum time spent infected with obvious symptoms. 0 or greater.
	 * @param _minPeriodSymptomInfection the new Min Period Symptom Infection value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMinPeriodSymptomInfection(int _minPeriodSymptomInfection) {
		minPeriodSymptomInfection = _minPeriodSymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Max Period Symptom Infection property for Epidemic.
	 * @return Maximum time spent infected with obvious symptoms. 1 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getMaxPeriodSymptomInfection() {
		return maxPeriodSymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Max Period Symptom Infection property for Epidemic.
	 * Maximum time spent infected with obvious symptoms. 1 or greater.
	 * @param _maxPeriodSymptomInfection the new Max Period Symptom Infection value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMaxPeriodSymptomInfection(int _maxPeriodSymptomInfection) {
		maxPeriodSymptomInfection = _maxPeriodSymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Movement Probability property for Epidemic.
	 * @return The chance that an agent will move within a given period. May be any value between 0.0 and 1.0.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public double getMovementProbability() {
		return movementProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Movement Probability property for Epidemic.
	 * The chance that an agent will move within a given period. May be any value between 0.0 and 1.0.
	 * @param _movementProbability the new Movement Probability value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMovementProbability(double _movementProbability) {
		movementProbability = _movementProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Dimensions property for City.
	 * @return The size of each dimension.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int[] getCityDimensions() {
		return cityDimensions;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Dimensions property for City.
	 * The size of each dimension.
	 * @param _cityDimensions the new Dimensions value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setCityDimensions(int[] _cityDimensions) {
		cityDimensions = _cityDimensions;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Width property for City.
	 * @return The horizontal extent of the space.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getCityWidth() {
		return cityWidth;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Width property for City.
	 * The horizontal extent of the space.
	 * @param _cityWidth the new Width value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setCityWidth(int _cityWidth) {
		cityWidth = _cityWidth;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Height property for City.
	 * @return The vertical extent of the space.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getCityHeight() {
		return cityHeight;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Height property for City.
	 * The vertical extent of the space.
	 * @param _cityHeight the new Height value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setCityHeight(int _cityHeight) {
		cityHeight = _cityHeight;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the City property for Epidemic.
	 * @return 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public Scape getCity() {
		return city;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the City property for Epidemic.
	 * 
	 * @param _city the new City value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setCity(Scape _city) {
		city = _city;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Contacts property for Epidemic.
	 * @return 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public Scape getContacts() {
		return contacts;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Contacts property for Epidemic.
	 * 
	 * @param _contacts the new Contacts value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setContacts(Scape _contacts) {
		contacts = _contacts;
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public String getName() {
		if (name == null) {
			return "Epidemic " + getUID();
		} else {
			return name;
		}
	}
}
