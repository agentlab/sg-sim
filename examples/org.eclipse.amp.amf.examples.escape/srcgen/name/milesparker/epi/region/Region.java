package name.milesparker.epi.region;

import java.util.ArrayList;
import java.util.List;
import java.util.Collections;

import org.eclipse.core.runtime.IAdapterFactory;
import org.eclipse.amp.agf.IGraphicsAdapted;
import org.eclipse.amp.agf.IGraphicsAdapter;

import org.eclipse.swt.graphics.Color;
import org.eclipse.jface.viewers.IColorProvider;

import org.ascape.model.Agent;
import org.ascape.model.Cell;
import org.ascape.model.CellOccupant;
import org.ascape.model.HostCell;
import org.ascape.model.LocatedAgent;
import org.ascape.model.Scape;
import org.ascape.model.event.ScapeEvent;
import org.ascape.model.rule.Rule;
import org.ascape.model.rule.ExecuteThenUpdate;
import org.ascape.model.space.CollectionSpace;
import org.ascape.model.space.Coordinate;
import org.ascape.model.space.Coordinate2DDiscrete;
import org.ascape.model.space.Graph;
import org.ascape.model.space.Location;
import org.ascape.model.space.Singleton;
import org.ascape.runtime.NonGraphicRunner;
import org.ascape.util.Conditional;
import org.ascape.util.data.DataPoint;
import org.ascape.util.data.DataPointConcrete;
import org.ascape.util.vis.ColorFeature;
import org.ascape.util.vis.ColorFeatureConcrete;
import org.ascape.view.vis.ChartView;
import org.ascape.view.vis.GEFView;
import org.ascape.view.vis.GraphView;

import org.eclipse.amp.escape.runtime.extension.IAgentChild;

/**
 * <!-- begin-user-doc -->
 * Region Java Implementation.
 * 
 * Generated by AMF for model: EpidemicRegional.metaabm in project: org.eclipse.amp.amf.examples.escape 
 * <!-- end-user-doc -->
 * @generated
 */
public class Region extends Scape implements IGraphicsAdapted {

	/**
	 * <!-- begin-user-doc -->
	 * The number of citys to create.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int cityCount = 4;
	/**
	 * <!-- begin-user-doc -->
	 * The probability that any given individual will be infected at the beginning of the model run. For example, if this value is .15, and their are 100 individuals in the model, roughly 15 of those individuals will be infected at time 0.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private double initialInfectionProbability = .05;
	/**
	 * <!-- begin-user-doc -->
	 * The probability that proximity to a single neighbor for a single period will result in transmission of infection.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private double minContactTransmissionProbability = .08;
	/**
	 * <!-- begin-user-doc -->
	 * The probability that proximity to a single neighbor for a single period will result in transmission of infection.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private double maxContactTransmissionProbability = .16;
	/**
	 * <!-- begin-user-doc -->
	 * The probability that death will occur for a given individual as a result of infection.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private double caseMortalityRate = .05;
	/**
	 * <!-- begin-user-doc -->
	 * Minimum time from initial exposure to infectious asymptomatic or symptomatic state. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int minPeriodExposure = 12;
	/**
	 * <!-- begin-user-doc -->
	 * Maximum time from initial exposure to infectious asymptomatic or symptomatic state. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int maxPeriodExposure = 48;
	/**
	 * <!-- begin-user-doc -->
	 * Maximum time spent infected without showing symptoms. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int minPeriodAsymptomInfection = 24;
	/**
	 * <!-- begin-user-doc -->
	 * Maximum time spent infected without showing symptoms. May be zero!
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int maxPeriodAsymptomInfection = 96;
	/**
	 * <!-- begin-user-doc -->
	 * Minimum time spent infected with obvious symptoms. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int minPeriodSymptomInfection = 24;
	/**
	 * <!-- begin-user-doc -->
	 * Maximum time spent infected with obvious symptoms. 1 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int maxPeriodSymptomInfection = 168;
	/**
	 * <!-- begin-user-doc -->
	 * The liklihood that an agent will move within a given period.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private double movementProbability = .5;
	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private double migrationProbability = 0.1;
	/**
	 * <!-- begin-user-doc -->
	 * The number of regional locations to create.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int regionalLocationCount = 0;
	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private boolean initialCityAssigned = false;
	/**
	 * <!-- begin-user-doc -->
	 * The size of each dimension.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int[] regionalMapDimensions = new int[2];
	/**
	 * <!-- begin-user-doc -->
	 * The horizontal extent of the space.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int regionalMapWidth = 2;
	/**
	 * <!-- begin-user-doc -->
	 * The vertical extent of the space.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private int regionalMapHeight = 2;
	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private Scape regionalMap = null;

	private List<IAgentChild> children;

	public List<IAgentChild> getChildren() {
		return children;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Constructs a new Region.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public Region() {

		children = new ArrayList<IAgentChild>();

	}

	//todo, make this a useful value for evaluating compatibility of different versions of generated classes

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private static final long serialVersionUID = 89989998L;

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private static long nextUniqueID;

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private long uniqueID;

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public long getUID() {
		if (uniqueID == 0) {
			uniqueID = nextUniqueID++;
		}
		return uniqueID;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Clones the agent, ensuring that a unique id is assigned.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public Object clone() {
		try {
			Region clone = (Region) super.clone();
			clone.uniqueID = 0;
			return clone;
		} catch (Exception e) {
			throw new RuntimeException("Unexpected cloning exception: " + e);
		}
	}

	org.ascape.model.Scape cityScape;

	/**
	 * <!-- begin-user-doc -->
	 * Create an instance of City that will be used to populate the cityScape.
	 * Overide to customize the prototype, for example to change the views created for a member scape.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected City createCityPrototype() {
		City city = new City();
		city.setCoordinate(new Coordinate2DDiscrete(0, 0));
		return city;
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	static int next_vm_id;

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	int vm_unique_id;

	/**
	 * <!-- begin-user-doc -->
	 * Creates the members of Region.
	 * <!-- end-user-doc --> 
	 * @generated
	 */
	public void createScape() {
		super.createScape();

		setName("Region");
		City cityProto = createCityPrototype();
		cityScape = new Scape();
		cityScape.setName("Citys");
		cityScape.setPrototypeAgent(cityProto);
		cityScape.setExecutionOrder(Scape.RULE_ORDER);

		cityScape.setSize(getCityCount());
		regionalMap = new Scape(new org.ascape.model.space.Array2DMoore());
		regionalMap.setExecutionOrder(Scape.RULE_ORDER);
		regionalMap.setPrototypeAgent(new RegionalLocation());
		regionalMap.setExtent(new org.ascape.model.space.Coordinate2DDiscrete(
				getRegionalMapWidth(), getRegionalMapHeight()));

		regionalMap.setName("Regional Maps");
		((CollectionSpace) regionalMap.getSpace()).setPeriodic(true);
		add(regionalMap);
		org.ascape.model.Scape regionalLocationScape = regionalMap;

		add(cityScape);

		cityProto.setHostScape(regionalMap);
		regionalMap.getRules().clear();

		cityScape.addStatCollector(new org.ascape.util.data.StatCollectorCond(
				cityScape.getName() + " Population") {

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			private static final long serialVersionUID = 684614444640209893L;

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			@SuppressWarnings("unused")
			public final boolean meetsCondition(Object object) {
				return true;
			}
		});
		cityScape.setAutoCreate(false);
		cityScape.createScape();

		cityScape.addInitialRule(new Rule("Setup Location") {

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			private static final long serialVersionUID = 6846144446402098982L;

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			public void execute(Agent a) {
				((name.milesparker.epi.region.City) a).setupLocation();
			}
		});

	}

	/**
	 * <!-- begin-user-doc -->
	 * Creates UI views for Region.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void createGraphicViews() {
		super.createGraphicViews();
		createChartViews();
		create2DViews();
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void scapeSetup(ScapeEvent scapeEvent) {
		//Set the size of the scape populations, e.g. for mutable scapes that need to have their size reset

		cityScape.setSize(getCityCount());
	}

	/**
	 * <!-- begin-user-doc -->
	 * Returns the Scape containing Citys.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public org.ascape.model.Scape getCityScape() {
		return cityScape;
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected void createChartViews() {
		ChartView chart = new ChartView();

		final Region cityScape = new Region();
		cityScape.setRunner(new NonGraphicRunner());
		City city = new City() {

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			public void requestUpdate() {
			}

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			public Region getRegion() {
				return cityScape;
			}
		};
		cityScape.add(city);
		HostCell cityHost = new HostCell() {

			/**
			 * <!-- begin-user-doc -->
			 * 
			 * <!-- end-user-doc -->
			 * @generated
			 */
			public void requestUpdate() {
			}
		};
		cityHost.setOccupant((CellOccupant) city);

		IColorProvider cityStyle2DColorProvider = new CityStyle2DColorProvider();

		addView(chart);
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected void create2DViews() {
		addView(new GEFView());
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected void createGraphViews() {
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public IGraphicsAdapter getGraphicsAdapter() {
		return RegionGraphicsAdapter.getDefault();
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private Color getInferredChartColor(Object agent,
			IColorProvider colorProvider) {
		Color color = colorProvider.getForeground(agent);
		if (color == ColorFeature.BLACK) {
			color = ColorFeatureConcrete.createHSB(
					(float) java.lang.Math.random() * 360f, 1.0f, 0.8f);
		}
		return color;
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static void main(String[] args) {
		(new NonGraphicRunner())
				.openInstance("name.milesparker.epi.region.Region");
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */

	public void startSimulationAgentChild(int timeStep) {
		if (timeStep == getRoot().getRunner().getEarliestPeriod()) {
			for (IAgentChild tmp : children) {
				tmp.startSimulation(timeStep);
			}
		}
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */

	public void calculateTimeStep(int timeStep) {
		for (IAgentChild tmp : children) {
			tmp.calculate(timeStep);
		}
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the City Count property for Region.
	 * @return The number of citys to create.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getCityCount() {
		return cityCount;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the City Count property for Region.
	 * The number of citys to create.
	 * @param _cityCount the new City Count value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setCityCount(int _cityCount) {
		cityCount = _cityCount;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Initial Infection Probability property for Region.
	 * @return The probability that any given individual will be infected at the beginning of the model run. For example, if this value is .15, and their are 100 individuals in the model, roughly 15 of those individuals will be infected at time 0.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public double getInitialInfectionProbability() {
		return initialInfectionProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Initial Infection Probability property for Region.
	 * The probability that any given individual will be infected at the beginning of the model run. For example, if this value is .15, and their are 100 individuals in the model, roughly 15 of those individuals will be infected at time 0.
	 * @param _initialInfectionProbability the new Initial Infection Probability value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setInitialInfectionProbability(
			double _initialInfectionProbability) {
		initialInfectionProbability = _initialInfectionProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Min Contact Transmission Probability property for Region.
	 * @return The probability that proximity to a single neighbor for a single period will result in transmission of infection.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public double getMinContactTransmissionProbability() {
		return minContactTransmissionProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Min Contact Transmission Probability property for Region.
	 * The probability that proximity to a single neighbor for a single period will result in transmission of infection.
	 * @param _minContactTransmissionProbability the new Min Contact Transmission Probability value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMinContactTransmissionProbability(
			double _minContactTransmissionProbability) {
		minContactTransmissionProbability = _minContactTransmissionProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Max Contact Transmission Probability property for Region.
	 * @return The probability that proximity to a single neighbor for a single period will result in transmission of infection.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public double getMaxContactTransmissionProbability() {
		return maxContactTransmissionProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Max Contact Transmission Probability property for Region.
	 * The probability that proximity to a single neighbor for a single period will result in transmission of infection.
	 * @param _maxContactTransmissionProbability the new Max Contact Transmission Probability value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMaxContactTransmissionProbability(
			double _maxContactTransmissionProbability) {
		maxContactTransmissionProbability = _maxContactTransmissionProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Case Mortality Rate property for Region.
	 * @return The probability that death will occur for a given individual as a result of infection.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public double getCaseMortalityRate() {
		return caseMortalityRate;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Case Mortality Rate property for Region.
	 * The probability that death will occur for a given individual as a result of infection.
	 * @param _caseMortalityRate the new Case Mortality Rate value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setCaseMortalityRate(double _caseMortalityRate) {
		caseMortalityRate = _caseMortalityRate;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Min Period Exposure property for Region.
	 * @return Minimum time from initial exposure to infectious asymptomatic or symptomatic state. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getMinPeriodExposure() {
		return minPeriodExposure;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Min Period Exposure property for Region.
	 * Minimum time from initial exposure to infectious asymptomatic or symptomatic state. 0 or greater.
	 * @param _minPeriodExposure the new Min Period Exposure value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMinPeriodExposure(int _minPeriodExposure) {
		minPeriodExposure = _minPeriodExposure;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Max Period Exposure property for Region.
	 * @return Maximum time from initial exposure to infectious asymptomatic or symptomatic state. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getMaxPeriodExposure() {
		return maxPeriodExposure;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Max Period Exposure property for Region.
	 * Maximum time from initial exposure to infectious asymptomatic or symptomatic state. 0 or greater.
	 * @param _maxPeriodExposure the new Max Period Exposure value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMaxPeriodExposure(int _maxPeriodExposure) {
		maxPeriodExposure = _maxPeriodExposure;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Min Period Asymptom Infection property for Region.
	 * @return Maximum time spent infected without showing symptoms. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getMinPeriodAsymptomInfection() {
		return minPeriodAsymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Min Period Asymptom Infection property for Region.
	 * Maximum time spent infected without showing symptoms. 0 or greater.
	 * @param _minPeriodAsymptomInfection the new Min Period Asymptom Infection value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMinPeriodAsymptomInfection(int _minPeriodAsymptomInfection) {
		minPeriodAsymptomInfection = _minPeriodAsymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Max Period Asymptom Infection property for Region.
	 * @return Maximum time spent infected without showing symptoms. May be zero!
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getMaxPeriodAsymptomInfection() {
		return maxPeriodAsymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Max Period Asymptom Infection property for Region.
	 * Maximum time spent infected without showing symptoms. May be zero!
	 * @param _maxPeriodAsymptomInfection the new Max Period Asymptom Infection value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMaxPeriodAsymptomInfection(int _maxPeriodAsymptomInfection) {
		maxPeriodAsymptomInfection = _maxPeriodAsymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Min Period Symptom Infection property for Region.
	 * @return Minimum time spent infected with obvious symptoms. 0 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getMinPeriodSymptomInfection() {
		return minPeriodSymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Min Period Symptom Infection property for Region.
	 * Minimum time spent infected with obvious symptoms. 0 or greater.
	 * @param _minPeriodSymptomInfection the new Min Period Symptom Infection value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMinPeriodSymptomInfection(int _minPeriodSymptomInfection) {
		minPeriodSymptomInfection = _minPeriodSymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Max Period Symptom Infection property for Region.
	 * @return Maximum time spent infected with obvious symptoms. 1 or greater.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getMaxPeriodSymptomInfection() {
		return maxPeriodSymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Max Period Symptom Infection property for Region.
	 * Maximum time spent infected with obvious symptoms. 1 or greater.
	 * @param _maxPeriodSymptomInfection the new Max Period Symptom Infection value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMaxPeriodSymptomInfection(int _maxPeriodSymptomInfection) {
		maxPeriodSymptomInfection = _maxPeriodSymptomInfection;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Movement Probability property for Region.
	 * @return The liklihood that an agent will move within a given period.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public double getMovementProbability() {
		return movementProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Movement Probability property for Region.
	 * The liklihood that an agent will move within a given period.
	 * @param _movementProbability the new Movement Probability value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMovementProbability(double _movementProbability) {
		movementProbability = _movementProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Migration Probability property for Region.
	 * @return 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public double getMigrationProbability() {
		return migrationProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Migration Probability property for Region.
	 * 
	 * @param _migrationProbability the new Migration Probability value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setMigrationProbability(double _migrationProbability) {
		migrationProbability = _migrationProbability;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Regional Location Count property for Region.
	 * @return The number of regional locations to create.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getRegionalLocationCount() {
		return regionalLocationCount;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Regional Location Count property for Region.
	 * The number of regional locations to create.
	 * @param _regionalLocationCount the new Regional Location Count value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setRegionalLocationCount(int _regionalLocationCount) {
		regionalLocationCount = _regionalLocationCount;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Initial City Assigned property for Region.
	 * @return 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean isInitialCityAssigned() {
		return initialCityAssigned;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Initial City Assigned property for Region.
	 * 
	 * @param _initialCityAssigned the new Initial City Assigned value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setInitialCityAssigned(boolean _initialCityAssigned) {
		initialCityAssigned = _initialCityAssigned;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Dimensions property for Regional Map.
	 * @return The size of each dimension.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int[] getRegionalMapDimensions() {
		return regionalMapDimensions;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Dimensions property for Regional Map.
	 * The size of each dimension.
	 * @param _regionalMapDimensions the new Dimensions value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setRegionalMapDimensions(int[] _regionalMapDimensions) {
		regionalMapDimensions = _regionalMapDimensions;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Width property for Regional Map.
	 * @return The horizontal extent of the space.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getRegionalMapWidth() {
		return regionalMapWidth;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Width property for Regional Map.
	 * The horizontal extent of the space.
	 * @param _regionalMapWidth the new Width value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setRegionalMapWidth(int _regionalMapWidth) {
		regionalMapWidth = _regionalMapWidth;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Height property for Regional Map.
	 * @return The vertical extent of the space.
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public int getRegionalMapHeight() {
		return regionalMapHeight;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Height property for Regional Map.
	 * The vertical extent of the space.
	 * @param _regionalMapHeight the new Height value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setRegionalMapHeight(int _regionalMapHeight) {
		regionalMapHeight = _regionalMapHeight;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Gets the Regional Map property for Region.
	 * @return 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public Scape getRegionalMap() {
		return regionalMap;
	}

	/**
	 * <!-- begin-user-doc -->
	 * Sets the Regional Map property for Region.
	 * 
	 * @param _regionalMap the new Regional Map value
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setRegionalMap(Scape _regionalMap) {
		regionalMap = _regionalMap;
	}

	/**
	 * <!-- begin-user-doc -->
	 * 
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public String getName() {
		if (name == null) {
			return "Region " + getUID();
		} else {
			return name;
		}
	}
}
